<head>
    <script src="./build/easycanvas.standalone.prod.js"></script>
    <script src="./build/plugin.physics.standalone.prod.js"></script>
</head>

<style>
    body {
        margin: 10px;
        text-align: center;
    }
    canvas {
        border: 1px solid grey;
        max-width: 100%;
        max-height: 100%;
    }
</style>
<body>
    <canvas id="el"></canvas>
</body>

<script>
    // 在html直接写代码，不编译、不构建，不然应该用const的
    var width = 400, height = 600, ballSize = 30;

    // 尺寸
    var el = document.getElementById('el');
    var maxHeight = el.style.height = document.body.clientHeight - 20;
    if (document.body.clientWidth < document.body.clientHeight * 0.66) {
        var maxWidth = el.style.width = document.body.clientWidth - 20;
        el.style.height = (document.body.clientWidth - 20) / 2 * 3;
    }

    // 记录鼠标轨迹
    var mouse = {x: 300, y: 50};

    // 游戏状态
    var canShoot = true;
    var score = 0;

    // 图片
    var BALL = Easycanvas.imgLoader('./ball.png');
    var BLOCK = Easycanvas.imgLoader('./block.jpg');
    var TRIANGLE = Easycanvas.imgLoader('./triangle.png');

    // 用于碰撞检测
    var BALL_TYPE = 1;
    var BLOCK_TYPE = 2;
    var BORDER_TYPE = 3;
    var BOTTOM_TYPE = 4;

    var ballLeft = 0;
    var blockArray = [];

    // 初始化easycanvas实例
    var $Painter = new Easycanvas.painter();
    $Painter.register(el, {
        width: width,
        height: height,
        events: {
            mousemove: function ($e) {
                mouse.x = $e.canvasX;
                mouse.y = Math.max(30, $e.canvasY);
            },
            touchmove: function ($e) {
                mouse.x = $e.canvasX;
                mouse.y = Math.max(30, $e.canvasY);
            },
            mouseup: shoot,
            touchend: shoot,
        }
    });
    $Painter.start();

    $Painter.add({
        content: {
            text: function () {
                return '得分:' + score;
            }
        },
        style: {
            tx: 5, ty: 5,
            textAlign: 'left',
            textVerticalAlign: 'top',
            color: 'black'
        }
    });

    // 初始化easycanvas物理引擎
    var $space = new Easycanvas.class.sprite({
        physics: {
            gravity: 1,
            accuracy: 3,
        },
    });
    $Painter.add($space);

    // 设置easycanvas碰撞处理规则
    var space = $space.launch();
    // 球和球不碰撞（感觉看着很不真实啊，但是游戏就是这样的）
    space.addCollisionHandler(BALL_TYPE, BALL_TYPE, function (cp) {
        return false;
    });
    // 球和方块碰撞
    space.addCollisionHandler(BALL_TYPE, BLOCK_TYPE, null, null, null,
    function (cp) {
        var block = cp.b.$sprite.name === 'block' ? cp.b.$sprite : cp.b.$sprite;
        var ball = cp.a.$sprite.name === 'block' ? cp.a.$sprite : cp.a.$sprite;

        // 撞过一次就重置作用力（这样只剩下重力了，就开始往下掉）
        ball.$physics.body.resetForces();

        // 这里直接通过父对象从子对象拿数据，这种数据的依赖方式不好，但是这么简单个应用，无所谓了
        // 更好的是例如通过easycanvas的自定义事件广播下去
        block.children[0].content.text--;
        score++;
        if (!block.children[0].content.text) {
            // 把方块撞成0了，先隐藏
            block.style.visible = false;

            // 异步删除这个方块（为啥异步？因为要在碰撞处理之后再删，不然就透过去了）
            $Painter.nextTick(function () {
                block.physicsOff();
                block.remove();
                blockArray.splice(blockArray.indexOf(block), 1);
            });
        }
        return false;
    });
    // 球和侧边碰撞
    space.addCollisionHandler(BALL_TYPE, BORDER_TYPE, null, null, null, function (cp) {
        var ball = cp.a.$sprite.name === 'block' ? cp.a.$sprite : cp.a.$sprite;

        // 撞过一次就重置作用力（这样只剩下重力了，就开始往下掉）
        ball.$physics.body.resetForces();
        return false;
    });
    // 球和底部碰撞，准备收回
    space.addCollisionHandler(BALL_TYPE, BOTTOM_TYPE, function (cp) {
        var ball = cp.a.$sprite.name === 'ball' ? cp.a.$sprite : cp.a.$sprite;
        if (ball.toRemove) {
            return true;
        }

        ball.toRemove = true;
        ball.style.opacity = Easycanvas.transition.linear(1, 0, 500);
        setTimeout(function () {
            ball.physicsOff();
            ball.remove();
            ballLeft--;

            if (ballLeft === 0) {
                canShoot = true;

                blockArray.forEach(function (block) {
                    block.physicsOff();
                    block.physicsOn();
                    block.style.ty -= 50;
                    if (block.style.ty < 50) {
                        canShoot = false;
                    }
                });

                if (!canShoot) {
                    alert('You lose');
                } else {
                    startAim();
                    addBlock(5 + score / 5, true);
                    Math.random() < 0.5 && addBlock(5 + score / 6, true);
                    Math.random() < 0.3 && addBlock(5 + score / 7, true);
                    Math.random() < 0.2 && addBlock(5 + score / 8, true);
                }
            }
        }, 500);
        return true;
    });

    // 显示瞄准轨迹
    var startAim = function () {
        for (var i = 0; i < 7; i ++) {
            $Painter.add({
                content: {
                    img: BALL,
                },
                data: {
                    gap: i / 6,
                },
                style: {
                    tx: function () {
                        return 200 + (mouse.x - 200) * this.data.gap;
                    },
                    ty: function () {
                        return 20 + (mouse.y - 20) * this.data.gap;
                    },
                    tw: 20, th: 20,
                    opacity: 0.4,
                },
                hooks: {
                    shoot: function () {
                        this.remove();
                    }
                }
            });
        }
    };
    startAim();

    var shoot = function () {
        if (!canShoot) return;

        $Painter.broadcast('shoot');
        canShoot = false;

        var currentMouse = JSON.parse(JSON.stringify(mouse));
        for (var i = 0; i < 5; i++) {
            setTimeout(function () {
                addBall(currentMouse);
            }, i * 100);
        }
    };

    function addBall (mouse) {
        ballLeft++;
        var $ball = new Easycanvas.class.sprite({
            name: 'ball',
            content: {
                img: BALL,
            },
            physics: {
                shape: [
                    // 形状是一个以(ballSize / 2, ballSize / 2)为圆心的，半径也是ballSize / 2的圆
                    // 改成位运算符吧，看着能高大上一点（其实在这里卵用没有）
                    [ballSize >> 1, ballSize >> 1, ballSize >> 1]
                ],
                mass: 1, // 质量
                friction: 0.2, // 摩擦（摩擦太大了会损失能量）
                elasticity: 0.7, // 弹性
                collisionType: BALL_TYPE,
            },
            style: {
                tw: ballSize, th: ballSize,
                sx: 0, sy: 0,
                tx: 200,
                ty: 20,
                zIndex: 1,
            },
        });
        $space.add($ball);

        $ball.physicsOn();
        $Painter.nextTick(function () {
            $Painter.nextTick(function () {
                // 抵消重力
                $ball.$physics.body.applyForce({x: 0, y: 500}, {x: 0, y: 0});

                // 初速度
                var speed = {
                    x: (mouse.x - 200) / (20 - mouse.y),
                    y: 1
                };

                // 修正速度，确保从各个角度射出小球的速度差不多
                var muti = Math.sqrt(Math.pow(speed.x, 2) + Math.pow(speed.y, 2)) / 700;

                $ball.$physics.body.setVel({
                    x: -speed.x / muti,
                    y: -speed.y / muti,
                });
            });
        });
    }

    function addBlock (max, boolAddToBottom) {
        var deg = Math.floor(Math.random() * 360);
        var sprite = $space.add(new Easycanvas.class.sprite({
            name: 'block',
            content: {
                img: BLOCK,
            },
            physics: {
                shape: [
                    [[0, 0], [0, 30]],
                    [[0, 30], [30, 30]],
                    [[30, 30], [30, 0]],
                    [[30, 0], [0, 0]]
                ],
                mass: 100,
                friction: 0.1,
                elasticity: 0.8,
                collisionType: BLOCK_TYPE,
                static: true,
            },
            style: {
                tw: 30, th: 30,
                tx: Math.floor(Math.random() * (width - 100)) + 50,
                ty: boolAddToBottom ? 500 : height - 100 - Math.floor(Math.random() * 200),
                locate: 'lt',
                zIndex: Math.random(),
                rotate: deg,
            },
            children: [{
                content: {
                    text: Math.floor(Math.random() * max) + 1,
                },
                style: {
                    color: 'yellow',
                    textAlign: 'center',
                    textVerticalAlign: 'middle',
                    textFont: '28px Arial',
                    tx: 15, ty: 10
                }
            }]
        }));
        sprite.physicsOn();
        blockArray.push(sprite);
    }

    for (var i = 0; i < 5; i += 1) {
        addBlock(5);
    }

    // 上半部分的边，摩擦小、弹性大
    var borderSprite = $space.add(new Easycanvas.class.sprite({
        physics: {
            shape: [
                [[0, 0], [width, 0]],
                [[0, 0], [0, height * 0.9]],
                [[width, 0], [width, height * 0.9]],
            ],
            friction: 0.1,
            elasticity: 0.7,
            collisionType: BORDER_TYPE,
            static: true
        },
        style: {
            tx: 0, ty: 0, tw: width, th: height,
            locate: 'lt',
        },
    }));
    borderSprite.physicsOn();

    // 下半部分的边，摩擦大、弹性小
    var bottomSprite = $space.add(new Easycanvas.class.sprite({
        physics: {
            shape: [
                [[0, height], [width, height]],
                [[0, height * 0.9], [0, height]],
                [[width, height * 0.9], [width, height]],
            ],
            friction: 5,
            elasticity: 0,
            collisionType: BOTTOM_TYPE,
            static: true
        },
        style: {
            tx: 0, ty: 0, tw: width, th: height,
            locate: 'lt',
        },
    }));
    bottomSprite.physicsOn();
</script>